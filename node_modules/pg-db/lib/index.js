// Generated by CoffeeScript 1.11.1
var DB, async, asyncIgnorify, cache, domain, event, eventTypes, eventTypesMap, i, len, np, parse, parsedSqlCache, pg, uid,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  slice = [].slice;

pg = require('pg');

domain = require('domain');

async = require('async');

uid = require('rand-token').uid;

np = require('./named-params');

eventTypes = ['begin', 'beginComplete', 'execute', 'executeComplete', 'commit', 'commitComplete', 'rollback', 'rollbackComplete'];

eventTypesMap = {};

for (i = 0, len = eventTypes.length; i < len; i++) {
  event = eventTypes[i];
  eventTypesMap[event] = true;
}

parsedSqlCache = {};

parse = function(sql) {
  var parsedSql;
  parsedSql = parsedSqlCache[sql];
  if (!parsedSql) {
    parsedSql = np.parse(sql);
    parsedSqlCache[sql] = parsedSql;
  }
  return parsedSql;
};


/*
Wraps a function to ignore any returned or thrown errors.
If cb has no args (i.e. sync) it's turned into an async function instead.
 */

asyncIgnorify = function(cb) {
  if (cb.length === 0) {
    return function(callback) {
      var ignore;
      try {
        cb();
      } catch (error) {
        ignore = error;
      }
      return callback();
    };
  }
  return function(callback) {
    var ignore;
    try {
      return cb(function() {
        return callback();
      });
    } catch (error) {
      ignore = error;
      return callback();
    }
  };
};

DB = (function() {

  /*
  Creates a new instance.
  
  @param {string|object} config The config URL or object for the remote database.
  @param {object} opts Optional configuration properties.
   */
  function DB(config1, opts1) {
    var execTx, fn, fn1, j, k, len1, len2, name, ref, ref1;
    this.config = config1;
    this.opts = opts1 != null ? opts1 : {};
    this.end = bind(this.end, this);
    this.update = bind(this.update, this);
    this.queryOne = bind(this.queryOne, this);
    this.query = bind(this.query, this);
    this.execute = bind(this.execute, this);
    this.connect = bind(this.connect, this);
    this.emit = bind(this.emit, this);
    this.on = bind(this.on, this);
    this.poolKey = JSON.stringify(this.config);
    this.txKey = '_tx-' + this.poolKey;
    this._listeners = {};

    /*
    Execute task in a transaction.
    This will:
    1) Fetch a new connection from the pool
    2) Issue a BEGIN to start a new transaction
    3) Execute the task(...) callback
    4) Issue either a ROLLBACK or COMMIT (depending on whether task was successful)
    5) Execute the cb(...) callback
    
    @param {function} task The task to execution, a function(err, cb).
    @param {function} cb The callback to execute on transaction completion, a function(err, results...).
     */
    execTx = (function(_this) {
      return function(task, cb) {
        var txStack;
        txStack = (new Error()).stack;
        return _this.connect(function(err, client, done) {
          var activeDomain, doTxCompletionCallbacks, exitTxDomain, invokeCb, rollbackTx, tx, txd;
          if (err) {
            return cb(err);
          }
          activeDomain = process.domain;
          txd = domain.create();
          tx = txd[_this.txKey] = {
            id: uid(24),
            createdAt: new Date(),
            client: client,
            stack: txStack,
            onSuccess: [],
            onFailure: []
          };
          doTxCompletionCallbacks = function(err, cb) {
            var callbacks;
            callbacks = err ? tx.onFailure : tx.onSuccess;
            if (callbacks.length === 0) {
              return cb(null);
            }
            return async.series(callbacks, cb);
          };
          invokeCb = function(err, results) {
            return doTxCompletionCallbacks(err, function() {
              if (activeDomain) {
                return activeDomain.run(function() {
                  return cb(err, results);
                });
              } else {
                return cb(err, results);
              }
            });
          };
          exitTxDomain = function() {
            txd[_this.txKey] = null;
            return txd.exit();
          };
          rollbackTx = function(err, cb) {
            _this.emit('rollback', {
              tx: tx,
              err: err
            });
            return client.query('ROLLBACK', [], function(rollbackErr) {
              _this.emit('rollbackComplete', {
                tx: tx,
                err: err,
                rollbackErr: rollbackErr
              });
              done(err);
              return typeof cb === "function" ? cb(err) : void 0;
            });
          };
          txd.on('error', function(err) {
            exitTxDomain();
            if (activeDomain) {
              activeDomain.emit('error', err);
              return rollbackTx(err);
            } else {
              return rollbackTx(err, invokeCb);
            }
          });
          return txd.run(function() {
            return async.series([
              function(cb) {
                _this.emit('begin', {
                  tx: tx
                });
                return cb(null);
              }, client.query.bind(client, 'BEGIN', []), function(cb) {
                _this.emit('beginComplete', {
                  tx: tx
                });
                return cb(null);
              }, task, function(cb) {
                _this.emit('commit', {
                  tx: tx
                });
                return cb(null);
              }, client.query.bind(client, 'COMMIT', [])
            ], function(err, results) {
              exitTxDomain();
              if (err) {
                return rollbackTx(err, invokeCb);
              }
              if (activeDomain) {
                activeDomain.run(function() {
                  return _this.emit('commitComplete', {
                    tx: tx
                  });
                });
              } else {
                _this.emit('commitComplete', {
                  tx: tx
                });
              }
              done();
              return invokeCb(null, results[3]);
            });
          });
        });
      };
    })(this);
    this.tx = execTx;
    this.tx.onSuccess = (function(_this) {
      return function(cb) {
        if (!_this.tx.active) {
          throw new Error('Transaction required');
        }
        if (typeof cb !== 'function') {
          throw new Error('cb must be a function');
        }
        return _this.tx.active.onSuccess.push(asyncIgnorify(cb));
      };
    })(this);
    this.tx.onFailure = (function(_this) {
      return function(cb) {
        if (!_this.tx.active) {
          throw new Error('Transaction required');
        }
        if (typeof cb !== 'function') {
          throw new Error('cb must be a function');
        }
        return _this.tx.active.onFailure.push(asyncIgnorify(cb));
      };
    })(this);
    ref = ['series', 'parallel', 'auto', 'waterfall'];
    fn = (function(_this) {
      return function(name) {
        var asyncFunc;
        asyncFunc = async[name];
        return _this.tx[name] = function(tasks, cb) {
          var task;
          task = function(cb) {
            return asyncFunc(tasks, cb);
          };
          return execTx(task, cb);
        };
      };
    })(this);
    for (j = 0, len1 = ref.length; j < len1; j++) {
      name = ref[j];
      fn(name);
    }

    /*
    Add transactional versions of helper functions.
    These functions check whether a transaction is active and if not return an error.
    If so, they invoke the equivalently named helper function
     */
    ref1 = ['execute', 'query', 'queryOne', 'update'];
    fn1 = (function(_this) {
      return function(name) {
        var helperFunc;
        helperFunc = _this[name];
        return _this.tx[name] = function(sql, params, cb) {
          if (!_this.tx.active) {
            if (!cb) {
              cb = params;
            }
            return setImmediate(cb, new Error('Transaction required'));
          }
          return helperFunc(sql, params, cb);
        };
      };
    })(this);
    for (k = 0, len2 = ref1.length; k < len2; k++) {
      name = ref1[k];
      fn1(name);
    }

    /*
    Getter to return the active transaction.
    If no transaction is active then null is returned.
     */
    Object.defineProperty(this.tx, 'active', {
      get: (function(_this) {
        return function() {
          var ref2;
          return ((ref2 = process.domain) != null ? ref2[_this.txKey] : void 0) || null;
        };
      })(this)
    });
  }


  /*
  Add an event listener.
   */

  DB.prototype.on = function(event, listener) {
    var base;
    if (!eventTypesMap[event]) {
      throw new Error('invalid event type: ' + event);
    }
    if (typeof listener !== 'function') {
      throw new Error('listener must be a function');
    }
    (base = this._listeners)[event] || (base[event] = []);
    return this._listeners[event].push(listener);
  };

  DB.prototype.emit = function() {
    var data, event, j, len1, listener, listeners, results1;
    event = arguments[0], data = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (!eventTypesMap[event]) {
      throw new Error('invalid event type: ' + event);
    }
    listeners = this._listeners[event];
    if (!listeners) {
      return;
    }
    results1 = [];
    for (j = 0, len1 = listeners.length; j < len1; j++) {
      listener = listeners[j];
      results1.push(listener.apply(null, data));
    }
    return results1;
  };


  /*
  Convenience function to get a connection from the pool.
  This is a thin wrapper around pg.connect(...) using the supplied connection config.
  
  @params {function} cb The callback to be invoked with the connection, function(err, client, done)
   */

  DB.prototype.connect = function(cb) {
    return pg.connect(this.config, cb);
  };


  /*
  Low level function to execute a SQL command.
  If an active transaction is in progress then the shared client for that transaction will be used.
  If not, a random connection will be retrieved from the pool of connections.
  
  NOTE: This function may be called with two arguments (skipping the "params" arg).
  
  @param {string} sql The SQL to execute.
  @param {array|object} params Optional parameters for the SQL command.
  @param {function} cb The callback to be invoked on completion of the command, function(err, result).
   */

  DB.prototype.execute = function(sql, params, cb) {
    var executeInternal, originalParams, originalSql, parseError, parsedSql, stack, startedAt;
    if (!cb) {
      cb = params;
      params = [];
    }
    if (typeof cb !== 'function') {
      throw new Error('cb must be a function');
    }
    if (typeof sql !== 'string') {
      return setImmediate(cb, new Error('sql must be a string'));
    }
    if (!Array.isArray(params) && typeof params !== 'object') {
      return setImmediate(cb, new Error('params must be an array or object'));
    }
    startedAt = new Date();
    stack = new Error().stack;
    originalSql = sql;
    originalParams = params;
    if (params && !Array.isArray(params)) {
      try {
        parsedSql = parse(sql);
        params = np.convertParamValues(parsedSql, params);
        sql = parsedSql.sql;
      } catch (error) {
        parseError = error;
        return setImmediate(cb, parseError);
      }
    }
    executeInternal = (function(_this) {
      return function(client, sql, params, cb) {
        var connectedAt, executeId;
        executeId = uid(32);
        connectedAt = new Date();
        _this.emit('execute', {
          id: executeId,
          sql: originalSql,
          params: originalParams,
          parsedSql: sql,
          parsedParams: params,
          tx: _this.tx.active,
          stack: stack,
          startedAt: startedAt,
          connectedAt: connectedAt
        });
        return client.query(sql, params, function(err, result) {
          var completedAt, elapsed;
          completedAt = new Date();
          elapsed = completedAt.getTime() - startedAt.getTime();
          _this.emit('executeComplete', {
            id: executeId,
            startedAt: startedAt,
            connectedAt: connectedAt,
            completedAt: completedAt,
            elapsed: completedAt.getTime() - startedAt.getTime(),
            sql: originalSql,
            parsedSql: sql,
            params: params,
            tx: _this.tx.active,
            err: err,
            result: result,
            stack: stack
          });
          return cb(err, result);
        });
      };
    })(this);
    if (this.tx.active) {
      return executeInternal(this.tx.active.client, sql, params, cb);
    } else {
      return this.connect((function(_this) {
        return function(err, client, done) {
          if (err) {
            return cb(err);
          }
          return executeInternal(client, sql, params, function(err, result) {
            done(err);
            return cb(err, result);
          });
        };
      })(this));
    }
  };


  /*
  Wrapper atop execute(...) for queries that are expected to return a set of rows.
  
  NOTE: This function may be called with two arguments (skipping the "params" arg).
  
  @param {string} sql The SQL to execute.
  @param {array|object} params Optional parameters for the SQL command.
  @param {function} cb The callback to be invoked on completion of the command, function(err, rows).
   */

  DB.prototype.query = function(sql, params, cb) {
    if (!cb) {
      cb = params;
      params = [];
    }
    return this.execute(sql, params, (function(_this) {
      return function(err, result) {
        return cb(err, result != null ? result.rows : void 0);
      };
    })(this));
  };


  /*
  Wrapper atop execute(...) for queries that are expected to return a single row.
  If the result contains no rows then "null" will be returned.
  If the result contains more than one row then an Error will be returned.
  
  NOTE: This function may be called with two arguments (skipping the "params" arg).
  
  @param {string} sql The SQL to execute.
  @param {array|object} params Optional parameters for the SQL command.
  @param {function} cb The callback to be invoked on completion of the command, function(err, row).
   */

  DB.prototype.queryOne = function(sql, params, cb) {
    if (!cb) {
      cb = params;
      params = [];
    }
    return this.execute(sql, params, (function(_this) {
      return function(err, result) {
        if ((result != null ? result.rows.length : void 0) > 1) {
          return cb(new Error('Expected 1 row but result returned ' + result.rows.length + 'rows'));
        }
        return cb(err, (result != null ? result.rows[0] : void 0) || null);
      };
    })(this));
  };


  /*
  Wrapper atop execute(...) for queries that are expected only return an updated row count.
  Ex: INSERT or UPDATE statements without a RETURNING ... clause.
  
  NOTE: This function may be called with two arguments (skipping the "params" arg).
  
  @param {string} sql The SQL to execute.
  @param {array|object} params Optional parameters for the SQL command.
  @param {function} cb The callback to be invoked on completion of the command, function(err, rowCount).
   */

  DB.prototype.update = function(sql, params, cb) {
    if (!cb) {
      cb = params;
      params = [];
    }
    return this.execute(sql, params, (function(_this) {
      return function(err, result) {
        return cb(err, result != null ? result.rowCount : void 0);
      };
    })(this));
  };


  /*
  Shutdown the connection pool and close all open connections.
  
  @param {function} cb Optional callback to be invoked after connection pool is closed.
   */

  DB.prototype.end = function(cb) {
    var pool;
    pool = pg.pools.all[this.poolKey];
    if (pool) {
      return pool.drain(function() {
        return pool.destroyAllNow(cb || function() {});
      });
    } else {
      if (cb) {
        return setImmediate(cb);
      }
    }
  };

  return DB;

})();

cache = {};


/*
@param {object|string} config The connection confirg, defaults to process.env.DATABASE_URL
@param {object} opts Additional options (optional)
@returns {object} A DB helper object.
 */

module.exports = function(config, opts) {
  var cacheKey;
  config || (config = process.env.DATABASE_URL);
  if (!config) {
    throw new Error('config or process.env.DATABASE_URL is required');
  }
  cacheKey = JSON.stringify(config);
  if (!cache[cacheKey]) {
    cache[cacheKey] = new DB(config, opts);
  }
  return cache[cacheKey];
};
