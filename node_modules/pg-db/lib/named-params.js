// Generated by CoffeeScript 1.11.1
var PARAMETER_SEPARATORS, SKIPS, convertParamValues, isParamSeparator, parse, skipCommentsAndQuotes,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

PARAMETER_SEPARATORS = ['"', '\'', ':', '&', ',', ';', '(', ')', '|', '=', '+', '-', '*', '%', '/', '\\', '<', '>', '^'];

SKIPS = [
  {
    start: "'",
    stop: "'"
  }, {
    start: "\"",
    stop: "\""
  }, {
    start: "--",
    stop: "\n"
  }, {
    start: "/*",
    stop: "*/"
  }
];

isParamSeparator = function(c) {
  return /\s/.test(c) || indexOf.call(PARAMETER_SEPARATORS, c) >= 0;
};

skipCommentsAndQuotes = function(sql, position) {
  var k, len, skip;
  for (k = 0, len = SKIPS.length; k < len; k++) {
    skip = SKIPS[k];
    if (sql.substr(position, skip.start.length) !== skip.start) {
      continue;
    }
    position += skip.start.length;
    while (sql.substr(position, skip.stop.length) !== skip.stop) {
      position++;
      if (position >= sql.length) {
        return sql.length;
      }
    }
    position += skip.stop.length;
  }
  return position;
};

parse = function(sql) {
  var i, j, k, l, len, namedParam, namedParams, param, paramCount, paramTypes, params, ref, ref1, ref2, ret, skipPos, throwError;
  if (typeof sql !== 'string') {
    throw new Error('sql must be a string');
  }
  params = [];
  i = 0;
  throwError = function(msg, pos) {
    pos = pos || i;
    throw new Error((msg || 'Error') + ' at position ' + pos + ' in statment ' + sql);
  };
  while (i < sql.length) {
    skipPos = i;
    while (i < sql.length) {
      skipPos = skipCommentsAndQuotes(sql, i);
      if (i === skipPos) {
        break;
      }
      i = skipPos;
    }
    if (i >= sql.length) {
      break;
    }
    if ((ref = sql[i]) === ':' || ref === '&' || ref === '$') {
      if (sql.substr(i, 2) === '::') {
        i += 2;
        continue;
      }
      j = i + 1;
      if (sql.substr(i, 2) === ':{') {
        while (j < sql.length && '}' !== sql[j]) {
          j++;
          if ((ref1 = sql[j]) === ':' || ref1 === '{') {
            throwError('Parameter name contains invalid character "' + sql[j] + '"');
          }
        }
        if (j >= sql.length) {
          throwError('Non-terminated named parameter declaration)');
        }
        if (j - i > 3) {
          params.push({
            name: sql.substring(i + 2, j),
            start: i,
            end: j + 1,
            type: ':{}'
          });
        }
        j++;
      } else {
        while (j < sql.length && !isParamSeparator(sql[j])) {
          j++;
        }
        if ((j - i) > 1) {
          params.push({
            name: sql.substring(i + 1, j),
            start: i,
            end: j,
            type: sql[i]
          });
        }
      }
      i = j - 1;
    }
    i++;
  }
  ret = {
    sql: sql,
    originalSql: sql,
    params: [],
    numParams: params.length,
    numDistinctParams: 0
  };
  paramTypes = {};
  namedParams = {};
  paramCount = 0;
  for (k = 0, len = params.length; k < len; k++) {
    param = params[k];
    paramCount++;
    paramTypes[param.type] = (paramTypes[param.type] || 0) + 1;
    if (/^[0-9]+$/.test(param.name)) {
      throwError('You cannot mix named and numbered parameters. Check parameter "' + param.name + '"', param.start);
    }
    namedParam = namedParams[param.name];
    if (!namedParam) {
      ret.numDistinctParams++;
      namedParam = {
        name: param.name,
        index: ret.numDistinctParams,
        indexes: []
      };
      namedParams[param.name] = namedParam;
      ret.params.push(namedParam);
    }
    namedParam.indexes.push(paramCount);
  }
  if (Object.keys(paramTypes).length > 1) {
    throw new Error('You cannot mix multiple types of parameters in statement: ' + sql);
  }
  if (ret.numParams > 0) {
    for (i = l = ref2 = ret.numParams - 1; ref2 <= 0 ? l <= 0 : l >= 0; i = ref2 <= 0 ? ++l : --l) {
      param = params[i];
      namedParam = namedParams[param.name];
      ret.sql = ret.sql.substring(0, param.start) + '$' + namedParam.index + ret.sql.substring(param.end);
    }
  }
  return ret;
};

convertParamValues = function(parsedSql, values) {
  var k, len, param, ref, ret;
  ret = [];
  ref = parsedSql.params;
  for (k = 0, len = ref.length; k < len; k++) {
    param = ref[k];
    if (param.name in values) {
      ret.push(values[param.name]);
    } else {
      throw new Error('No value found for parameter: ' + param.name);
    }
  }
  return ret;
};

module.exports = {

  /*
  The object returned by this function has the following properties:
    sql {string} The parsed SQL with named parameters replaced with $1, $2, ...
    originalSql {string} The original SQL, unchanged.
    params {array} An array of the parameters in the SQL.
    numParams {number} The total number of parameters.
    numDistinctParams {number} The number of uniquely named parameters.
  
  Each param object has the following properties:
    name {string} The name of the parameter
    index {number} The first index the parameter is used.
    indexes {array[number]} All the indexes for which the parameter is used.
  
  @param {string} sql The SQL to parse for named parameters.
  @return {object} The parsed SQL with named parameters replaced with $1, $2, ... references.
   */
  parse: parse,
  convertParamValues: convertParamValues,
  isParamSeparator: isParamSeparator,
  skipCommentsAndQuotes: skipCommentsAndQuotes
};
